"""
shared/models/task_requirements.py

Task requirements model for dynamic agent selection.
Represents extracted and analyzed requirements from task descriptions and multimodal inputs.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Set, Optional, Any
from datetime import datetime
from enum import Enum

from .agent_capability import InputModality


class TaskComplexity(Enum):
    """Task complexity levels."""
    TRIVIAL = "trivial"  # < 50 LOC, simple logic
    LOW = "low"  # 50-200 LOC, straightforward
    MEDIUM = "medium"  # 200-500 LOC, moderate complexity
    HIGH = "high"  # 500-2000 LOC, complex logic
    VERY_HIGH = "very_high"  # > 2000 LOC, very complex


class TaskPriorityLevel(Enum):
    """Task priority levels."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class NFRRequirement:
    """Non-functional requirement specification."""
    nfr_type: str  # "performance", "security", "scalability", "availability"
    metric: str  # "latency_ms", "throughput_tps", "uptime_percent"
    target_value: float
    threshold_value: float  # Acceptable minimum/maximum
    priority: TaskPriorityLevel = TaskPriorityLevel.MEDIUM


@dataclass
class InputSource:
    """Source of task input (file, URL, user description, etc.)."""
    source_type: str  # "file", "url", "text", "design_file", "video"
    source_path: Optional[str] = None
    modality: InputModality = InputModality.TEXT
    content_summary: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class TaskRequirements:
    """
    Requirements extracted from task analysis.

    Generated by TaskAnalyzer from multimodal inputs and natural language descriptions.
    """

    # ============================================================================
    # Core Identification
    # ============================================================================
    task_id: str
    description: str
    title: Optional[str] = None

    # ============================================================================
    # Required Capabilities
    # ============================================================================
    required_capabilities: Set[str] = field(default_factory=set)
    """
    Required capability tags that agents must have, e.g.:
    - "react_development", "api_design", "database_modeling"
    - "code_implementation", "test_generation", "deployment"
    """

    optional_capabilities: Set[str] = field(default_factory=set)
    """Optional capabilities that enhance the solution if available."""

    # ============================================================================
    # Input Information
    # ============================================================================
    input_modalities: Set[InputModality] = field(default_factory=lambda: {InputModality.TEXT})
    """Types of input provided for this task."""

    input_sources: List[InputSource] = field(default_factory=list)
    """Detailed information about input sources."""

    input_files: List[str] = field(default_factory=list)
    """Paths to input files."""

    # ============================================================================
    # Output Requirements
    # ============================================================================
    output_types: Set[str] = field(default_factory=set)
    """
    Expected output types, e.g.:
    - "typescript_code", "react_components", "api_spec"
    - "database_schema", "deployment_manifest", "test_cases"
    """

    output_requirements: Dict[str, Any] = field(default_factory=dict)
    """Specific requirements for outputs (formatting, structure, etc.)."""

    deliverables: List[str] = field(default_factory=list)
    """List of specific deliverables expected."""

    # ============================================================================
    # Technology Stack Requirements
    # ============================================================================
    required_language: Optional[str] = None
    """Required programming language."""

    preferred_languages: List[str] = field(default_factory=list)
    """Preferred languages in order of preference."""

    required_framework: Optional[str] = None
    """Required framework."""

    preferred_frameworks: List[str] = field(default_factory=list)
    """Preferred frameworks."""

    required_platform: Optional[str] = None
    """Required platform (web, mobile, cloud, etc.)."""

    cloud_provider: Optional[str] = None
    """Required cloud provider (gcp, aws, azure)."""

    # ============================================================================
    # Complexity and Size Estimates
    # ============================================================================
    estimated_complexity: TaskComplexity = TaskComplexity.MEDIUM
    """Overall complexity level."""

    estimated_lines_of_code: int = 500
    """Estimated lines of code."""

    estimated_duration_hours: float = 1.0
    """Estimated time to complete."""

    estimated_components: int = 1
    """Number of components to be created/modified."""

    complexity_factors: List[str] = field(default_factory=list)
    """Factors contributing to complexity (e.g., "concurrent_processing", "legacy_integration")."""

    # ============================================================================
    # Dependencies and Relationships
    # ============================================================================
    dependencies: List[str] = field(default_factory=list)
    """Other task IDs this task depends on."""

    blocks: List[str] = field(default_factory=list)
    """Task IDs that this task blocks."""

    related_tasks: List[str] = field(default_factory=list)
    """Related task IDs for context."""

    prerequisite_components: List[str] = field(default_factory=list)
    """Components that must exist before this task can be completed."""

    # ============================================================================
    # Non-Functional Requirements
    # ============================================================================
    nfr_requirements: List[NFRRequirement] = field(default_factory=list)
    """Non-functional requirements (performance, security, etc.)."""

    performance_targets: Dict[str, float] = field(default_factory=dict)
    """Performance targets (latency_ms, throughput_tps, etc.)."""

    security_requirements: List[str] = field(default_factory=list)
    """Security requirements (authentication, encryption, compliance)."""

    compliance_standards: List[str] = field(default_factory=list)
    """Compliance standards to meet (GDPR, HIPAA, etc.)."""

    # ============================================================================
    # Knowledge Base Requirements
    # ============================================================================
    requires_kb_access: bool = True
    """Whether this task requires knowledge base access."""

    kb_search_context: Dict[str, Any] = field(default_factory=dict)
    """Pre-defined search parameters for KB queries."""

    expected_kb_queries: int = 5
    """Estimated number of KB lookups needed."""

    kb_query_types: List[str] = field(default_factory=lambda: [
        "similar_implementations", "best_practices"
    ])
    """Types of KB queries expected for this task."""

    # ============================================================================
    # Constraints
    # ============================================================================
    max_cost_usd: Optional[float] = None
    """Maximum acceptable cost for this task."""

    deadline: Optional[str] = None
    """Deadline (ISO format timestamp)."""

    max_duration_hours: Optional[float] = None
    """Maximum time allowed for completion."""

    must_use_agents: List[str] = field(default_factory=list)
    """Specific agents that must be used."""

    must_avoid_agents: List[str] = field(default_factory=list)
    """Agents that should not be used."""

    resource_constraints: Dict[str, Any] = field(default_factory=dict)
    """Other resource constraints (memory, CPU, etc.)."""

    # ============================================================================
    # Priority and Urgency
    # ============================================================================
    priority: TaskPriorityLevel = TaskPriorityLevel.MEDIUM
    """Task priority level."""

    is_blocking: bool = False
    """Whether this task blocks other critical tasks."""

    urgency_score: float = 0.5
    """Urgency score (0.0 to 1.0)."""

    # ============================================================================
    # Validation Criteria
    # ============================================================================
    validation_criteria: List[str] = field(default_factory=list)
    """Criteria for validating task completion."""

    acceptance_criteria: List[str] = field(default_factory=list)
    """User acceptance criteria."""

    test_requirements: List[str] = field(default_factory=list)
    """Testing requirements."""

    # ============================================================================
    # Context and Metadata
    # ============================================================================
    business_context: Dict[str, Any] = field(default_factory=dict)
    """Business context and rationale."""

    user_stories: List[str] = field(default_factory=list)
    """Related user stories."""

    domain: Optional[str] = None
    """Business domain (fintech, healthcare, ecommerce, etc.)."""

    stakeholders: List[str] = field(default_factory=list)
    """Stakeholders for this task."""

    tags: Set[str] = field(default_factory=set)
    """Additional tags for categorization."""

    # ============================================================================
    # Timestamps
    # ============================================================================
    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    analyzed_at: Optional[str] = None
    """When requirements analysis was completed."""

    # ============================================================================
    # Analysis Metadata
    # ============================================================================
    confidence_score: float = 1.0
    """Confidence in the requirements analysis (0.0 to 1.0)."""

    analysis_method: str = "manual"
    """How requirements were extracted ("manual", "llm_analysis", "multimodal_analysis")."""

    extracted_from: List[str] = field(default_factory=list)
    """Sources from which requirements were extracted."""

    ambiguities: List[str] = field(default_factory=list)
    """Identified ambiguities or uncertainties."""

    assumptions: List[str] = field(default_factory=list)
    """Assumptions made during analysis."""

    # ============================================================================
    # Methods
    # ============================================================================

    def add_capability(self, capability: str, required: bool = True):
        """Add a required or optional capability."""
        if required:
            self.required_capabilities.add(capability)
        else:
            self.optional_capabilities.add(capability)

    def add_nfr(self, nfr: NFRRequirement):
        """Add a non-functional requirement."""
        self.nfr_requirements.append(nfr)

    def add_input_source(self, source: InputSource):
        """Add an input source."""
        self.input_sources.append(source)
        self.input_modalities.add(source.modality)

    def set_complexity(
        self,
        complexity: TaskComplexity,
        estimated_loc: Optional[int] = None,
        estimated_hours: Optional[float] = None
    ):
        """Set complexity with optional estimates."""
        self.estimated_complexity = complexity

        if estimated_loc:
            self.estimated_lines_of_code = estimated_loc

        if estimated_hours:
            self.estimated_duration_hours = estimated_hours

    def requires_multimodal_processing(self) -> bool:
        """Check if task requires multimodal input processing."""
        multimodal_types = {
            InputModality.IMAGE,
            InputModality.VIDEO,
            InputModality.AUDIO,
            InputModality.PDF,
            InputModality.DESIGN_FILE
        }
        return bool(self.input_modalities & multimodal_types)

    def get_estimated_cost(
        self,
        cost_per_hour: float = 0.10
    ) -> float:
        """
        Calculate estimated cost based on duration and KB queries.

        Args:
            cost_per_hour: Cost per hour of agent time

        Returns:
            Estimated cost in USD
        """
        base_cost = self.estimated_duration_hours * cost_per_hour
        kb_cost = self.expected_kb_queries * 0.001  # ~$0.001 per query
        return base_cost + kb_cost

    def is_feasible(
        self,
        max_complexity: Optional[TaskComplexity] = None,
        max_cost: Optional[float] = None,
        max_duration: Optional[float] = None
    ) -> bool:
        """
        Check if task is feasible within given constraints.

        Args:
            max_complexity: Maximum acceptable complexity
            max_cost: Maximum acceptable cost
            max_duration: Maximum acceptable duration

        Returns:
            True if task is feasible
        """
        if max_complexity and self.estimated_complexity.value > max_complexity.value:
            return False

        if max_cost and self.get_estimated_cost() > max_cost:
            return False

        if max_duration and self.estimated_duration_hours > max_duration:
            return False

        return True

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "task_id": self.task_id,
            "description": self.description,
            "title": self.title,
            "required_capabilities": list(self.required_capabilities),
            "optional_capabilities": list(self.optional_capabilities),
            "input_modalities": [m.value for m in self.input_modalities],
            "output_types": list(self.output_types),
            "required_language": self.required_language,
            "required_framework": self.required_framework,
            "estimated_complexity": self.estimated_complexity.value,
            "estimated_lines_of_code": self.estimated_lines_of_code,
            "estimated_duration_hours": self.estimated_duration_hours,
            "dependencies": self.dependencies,
            "requires_kb_access": self.requires_kb_access,
            "expected_kb_queries": self.expected_kb_queries,
            "priority": self.priority.value,
            "deadline": self.deadline,
            "validation_criteria": self.validation_criteria,
            "created_at": self.created_at,
            "confidence_score": self.confidence_score
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TaskRequirements':
        """Create TaskRequirements from dictionary."""
        # Parse enums
        input_modalities = {InputModality(m) for m in data.get("input_modalities", ["text"])}
        complexity = TaskComplexity(data.get("estimated_complexity", "medium"))
        priority = TaskPriorityLevel(data.get("priority", "medium"))

        return cls(
            task_id=data["task_id"],
            description=data["description"],
            title=data.get("title"),
            required_capabilities=set(data.get("required_capabilities", [])),
            optional_capabilities=set(data.get("optional_capabilities", [])),
            input_modalities=input_modalities,
            output_types=set(data.get("output_types", [])),
            required_language=data.get("required_language"),
            required_framework=data.get("required_framework"),
            estimated_complexity=complexity,
            estimated_lines_of_code=data.get("estimated_lines_of_code", 500),
            estimated_duration_hours=data.get("estimated_duration_hours", 1.0),
            dependencies=data.get("dependencies", []),
            requires_kb_access=data.get("requires_kb_access", True),
            expected_kb_queries=data.get("expected_kb_queries", 5),
            priority=priority,
            deadline=data.get("deadline"),
            validation_criteria=data.get("validation_criteria", []),
            created_at=data.get("created_at", datetime.utcnow().isoformat()),
            confidence_score=data.get("confidence_score", 1.0)
        )

    def __str__(self) -> str:
        """String representation."""
        return f"TaskRequirements({self.task_id}, complexity={self.estimated_complexity.value}, capabilities={len(self.required_capabilities)})"

    def __repr__(self) -> str:
        """Detailed representation."""
        return self.__str__()
